// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/hubogle/chatcode-server/internal/dal/model"
)

func newMessageBasic(db *gorm.DB, opts ...gen.DOOption) messageBasic {
	_messageBasic := messageBasic{}

	_messageBasic.messageBasicDo.UseDB(db, opts...)
	_messageBasic.messageBasicDo.UseModel(&model.MessageBasic{})

	tableName := _messageBasic.messageBasicDo.TableName()
	_messageBasic.ALL = field.NewAsterisk(tableName)
	_messageBasic.ID = field.NewUint64(tableName, "id")
	_messageBasic.UserUID = field.NewUint64(tableName, "user_uid")
	_messageBasic.SenderUID = field.NewUint64(tableName, "sender_uid")
	_messageBasic.RoomUID = field.NewString(tableName, "room_uid")
	_messageBasic.SessionType = field.NewInt32(tableName, "session_type")
	_messageBasic.Content = field.NewString(tableName, "content")
	_messageBasic.ContentType = field.NewInt32(tableName, "content_type")
	_messageBasic.SendAt = field.NewInt64(tableName, "send_at")
	_messageBasic.CreatedAt = field.NewInt64(tableName, "created_at")
	_messageBasic.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_messageBasic.DeletedAt = field.NewInt64(tableName, "deleted_at")

	_messageBasic.fillFieldMap()

	return _messageBasic
}

type messageBasic struct {
	messageBasicDo

	ALL         field.Asterisk
	ID          field.Uint64
	UserUID     field.Uint64 // 接收者ID
	SenderUID   field.Uint64 // 发送者ID
	RoomUID     field.String // 房间ID
	SessionType field.Int32  // 会话类型 1:群聊 2:私聊
	Content     field.String // 聊天内容
	ContentType field.Int32  // 聊天内容类型 1:文本 2:图片 3:视频 4:音频 5:文件
	SendAt      field.Int64  // 发送时间
	CreatedAt   field.Int64
	UpdatedAt   field.Int64
	DeletedAt   field.Int64

	fieldMap map[string]field.Expr
}

func (m messageBasic) Table(newTableName string) *messageBasic {
	m.messageBasicDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m messageBasic) As(alias string) *messageBasic {
	m.messageBasicDo.DO = *(m.messageBasicDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *messageBasic) updateTableName(table string) *messageBasic {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewUint64(table, "id")
	m.UserUID = field.NewUint64(table, "user_uid")
	m.SenderUID = field.NewUint64(table, "sender_uid")
	m.RoomUID = field.NewString(table, "room_uid")
	m.SessionType = field.NewInt32(table, "session_type")
	m.Content = field.NewString(table, "content")
	m.ContentType = field.NewInt32(table, "content_type")
	m.SendAt = field.NewInt64(table, "send_at")
	m.CreatedAt = field.NewInt64(table, "created_at")
	m.UpdatedAt = field.NewInt64(table, "updated_at")
	m.DeletedAt = field.NewInt64(table, "deleted_at")

	m.fillFieldMap()

	return m
}

func (m *messageBasic) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *messageBasic) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 11)
	m.fieldMap["id"] = m.ID
	m.fieldMap["user_uid"] = m.UserUID
	m.fieldMap["sender_uid"] = m.SenderUID
	m.fieldMap["room_uid"] = m.RoomUID
	m.fieldMap["session_type"] = m.SessionType
	m.fieldMap["content"] = m.Content
	m.fieldMap["content_type"] = m.ContentType
	m.fieldMap["send_at"] = m.SendAt
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["updated_at"] = m.UpdatedAt
	m.fieldMap["deleted_at"] = m.DeletedAt
}

func (m messageBasic) clone(db *gorm.DB) messageBasic {
	m.messageBasicDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m messageBasic) replaceDB(db *gorm.DB) messageBasic {
	m.messageBasicDo.ReplaceDB(db)
	return m
}

type messageBasicDo struct{ gen.DO }

type IMessageBasicDo interface {
	gen.SubQuery
	Debug() IMessageBasicDo
	WithContext(ctx context.Context) IMessageBasicDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMessageBasicDo
	WriteDB() IMessageBasicDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMessageBasicDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMessageBasicDo
	Not(conds ...gen.Condition) IMessageBasicDo
	Or(conds ...gen.Condition) IMessageBasicDo
	Select(conds ...field.Expr) IMessageBasicDo
	Where(conds ...gen.Condition) IMessageBasicDo
	Order(conds ...field.Expr) IMessageBasicDo
	Distinct(cols ...field.Expr) IMessageBasicDo
	Omit(cols ...field.Expr) IMessageBasicDo
	Join(table schema.Tabler, on ...field.Expr) IMessageBasicDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMessageBasicDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMessageBasicDo
	Group(cols ...field.Expr) IMessageBasicDo
	Having(conds ...gen.Condition) IMessageBasicDo
	Limit(limit int) IMessageBasicDo
	Offset(offset int) IMessageBasicDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMessageBasicDo
	Unscoped() IMessageBasicDo
	Create(values ...*model.MessageBasic) error
	CreateInBatches(values []*model.MessageBasic, batchSize int) error
	Save(values ...*model.MessageBasic) error
	First() (*model.MessageBasic, error)
	Take() (*model.MessageBasic, error)
	Last() (*model.MessageBasic, error)
	Find() ([]*model.MessageBasic, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MessageBasic, err error)
	FindInBatches(result *[]*model.MessageBasic, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MessageBasic) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMessageBasicDo
	Assign(attrs ...field.AssignExpr) IMessageBasicDo
	Joins(fields ...field.RelationField) IMessageBasicDo
	Preload(fields ...field.RelationField) IMessageBasicDo
	FirstOrInit() (*model.MessageBasic, error)
	FirstOrCreate() (*model.MessageBasic, error)
	FindByPage(offset int, limit int) (result []*model.MessageBasic, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMessageBasicDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m messageBasicDo) Debug() IMessageBasicDo {
	return m.withDO(m.DO.Debug())
}

func (m messageBasicDo) WithContext(ctx context.Context) IMessageBasicDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m messageBasicDo) ReadDB() IMessageBasicDo {
	return m.Clauses(dbresolver.Read)
}

func (m messageBasicDo) WriteDB() IMessageBasicDo {
	return m.Clauses(dbresolver.Write)
}

func (m messageBasicDo) Session(config *gorm.Session) IMessageBasicDo {
	return m.withDO(m.DO.Session(config))
}

func (m messageBasicDo) Clauses(conds ...clause.Expression) IMessageBasicDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m messageBasicDo) Returning(value interface{}, columns ...string) IMessageBasicDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m messageBasicDo) Not(conds ...gen.Condition) IMessageBasicDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m messageBasicDo) Or(conds ...gen.Condition) IMessageBasicDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m messageBasicDo) Select(conds ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m messageBasicDo) Where(conds ...gen.Condition) IMessageBasicDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m messageBasicDo) Order(conds ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m messageBasicDo) Distinct(cols ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m messageBasicDo) Omit(cols ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m messageBasicDo) Join(table schema.Tabler, on ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m messageBasicDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m messageBasicDo) RightJoin(table schema.Tabler, on ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m messageBasicDo) Group(cols ...field.Expr) IMessageBasicDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m messageBasicDo) Having(conds ...gen.Condition) IMessageBasicDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m messageBasicDo) Limit(limit int) IMessageBasicDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m messageBasicDo) Offset(offset int) IMessageBasicDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m messageBasicDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMessageBasicDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m messageBasicDo) Unscoped() IMessageBasicDo {
	return m.withDO(m.DO.Unscoped())
}

func (m messageBasicDo) Create(values ...*model.MessageBasic) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m messageBasicDo) CreateInBatches(values []*model.MessageBasic, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m messageBasicDo) Save(values ...*model.MessageBasic) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m messageBasicDo) First() (*model.MessageBasic, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MessageBasic), nil
	}
}

func (m messageBasicDo) Take() (*model.MessageBasic, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MessageBasic), nil
	}
}

func (m messageBasicDo) Last() (*model.MessageBasic, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MessageBasic), nil
	}
}

func (m messageBasicDo) Find() ([]*model.MessageBasic, error) {
	result, err := m.DO.Find()
	return result.([]*model.MessageBasic), err
}

func (m messageBasicDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MessageBasic, err error) {
	buf := make([]*model.MessageBasic, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m messageBasicDo) FindInBatches(result *[]*model.MessageBasic, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m messageBasicDo) Attrs(attrs ...field.AssignExpr) IMessageBasicDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m messageBasicDo) Assign(attrs ...field.AssignExpr) IMessageBasicDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m messageBasicDo) Joins(fields ...field.RelationField) IMessageBasicDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m messageBasicDo) Preload(fields ...field.RelationField) IMessageBasicDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m messageBasicDo) FirstOrInit() (*model.MessageBasic, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MessageBasic), nil
	}
}

func (m messageBasicDo) FirstOrCreate() (*model.MessageBasic, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MessageBasic), nil
	}
}

func (m messageBasicDo) FindByPage(offset int, limit int) (result []*model.MessageBasic, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m messageBasicDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m messageBasicDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m messageBasicDo) Delete(models ...*model.MessageBasic) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *messageBasicDo) withDO(do gen.Dao) *messageBasicDo {
	m.DO = *do.(*gen.DO)
	return m
}
